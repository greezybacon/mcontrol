
/**
 ** Automatically generated file -- do not modify directly
 **
 ** This file is generated by client.c.py which will compile the list of
 ** exported proxy functions from the given header files.
 **
 **/

#include <errno.h>
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include "../drivers/driver.h"
#include "../motor.h"
#include "message.h"
#include "dispatch.h"
#include "client.h"

// Default timeout for send/receive is defined here. The time should
// consider the send, remote process, remote send, and receive times
// together.
static struct timespec timeout = { .tv_nsec = 250e6 }; // 250ms

void
mcClientTimeoutSet(const struct timespec * new_timeout,
        struct timespec * old_timeout) {
    if (old_timeout != NULL)
        *old_timeout = timeout;
    timeout = *new_timeout;
}

#include "query.h"
#include "locks.h"
#include "motor.h"
#include "motion.h"
#include "events.h"
#include "profile.h"
#include "trace.h"
#include "firmware.h"

int mcConnect( String * connection, OUT MOTOR motor_t * motor) {
    if (connection == NULL) return -EINVAL;
    if (motor == NULL) return -EINVAL;
    struct _mcConnect_args payload = {
        .connection = *connection,
        .motor = *motor
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcConnect, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcConnect_args *) response.payload;

    memcpy(motor, &payload.motor, sizeof(MOTOR motor_t));
    return payload.returned;
}

int mcEventRegister(motor_t motor, int event) {
    
    struct _mcEventRegister_args payload = {
        .event = event
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcEventRegister, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcEventRegister_args *) response.payload;

    
    return payload.returned;
}

int mcEventUnregister(motor_t motor, int event) {
    
    struct _mcEventUnregister_args payload = {
        .event = event
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcEventUnregister, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcEventUnregister_args *) response.payload;

    
    return payload.returned;
}

int mcFirmwareLoad(motor_t motor, String * filename) {
    if (filename == NULL) return -EINVAL;
    struct _mcFirmwareLoad_args payload = {
        .filename = *filename
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcFirmwareLoad, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcFirmwareLoad_args *) response.payload;

    
    return payload.returned;
}

int mcHome(motor_t motor) {
    
    struct _mcHome_args payload = {
        
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcHome, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcHome_args *) response.payload;

    
    return payload.returned;
}

int mcJitter(motor_t motor, int loops, int max_travel) {
    
    struct _mcJitter_args payload = {
        .loops = loops,
        .max_travel = max_travel
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcJitter, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcJitter_args *) response.payload;

    
    return payload.returned;
}

int mcJitterUnits(motor_t motor, int loops, int max_travel, unit_type_t units) {
    
    struct _mcJitterUnits_args payload = {
        .loops = loops,
        .max_travel = max_travel,
        .units = units
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcJitterUnits, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcJitterUnits_args *) response.payload;

    
    return payload.returned;
}

int mcMicrocodeLoad(motor_t motor, String * filename) {
    if (filename == NULL) return -EINVAL;
    struct _mcMicrocodeLoad_args payload = {
        .filename = *filename
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMicrocodeLoad, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMicrocodeLoad_args *) response.payload;

    
    return payload.returned;
}

bool mcMotorIsLocked(motor_t motor) {
    
    struct _mcMotorIsLocked_args payload = {
        
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMotorIsLocked, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMotorIsLocked_args *) response.payload;

    
    return payload.returned;
}

int mcMotorLock(motor_t motor, int for_motor_id, lock_mode_t mode) {
    
    struct _mcMotorLock_args payload = {
        .for_motor_id = for_motor_id,
        .mode = mode
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMotorLock, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMotorLock_args *) response.payload;

    
    return payload.returned;
}

int mcMotorUnlock(motor_t motor, int for_motor_id) {
    
    struct _mcMotorUnlock_args payload = {
        .for_motor_id = for_motor_id
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMotorUnlock, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMotorUnlock_args *) response.payload;

    
    return payload.returned;
}

int mcMoveAbsolute(motor_t motor, int distance) {
    
    struct _mcMoveAbsolute_args payload = {
        .distance = distance
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMoveAbsolute, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMoveAbsolute_args *) response.payload;

    
    return payload.returned;
}

int mcMoveAbsoluteUnits(motor_t motor, int distance, unit_type_t units) {
    
    struct _mcMoveAbsoluteUnits_args payload = {
        .distance = distance,
        .units = units
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMoveAbsoluteUnits, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMoveAbsoluteUnits_args *) response.payload;

    
    return payload.returned;
}

int mcMoveRelative(motor_t motor, int distance) {
    
    struct _mcMoveRelative_args payload = {
        .distance = distance
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMoveRelative, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMoveRelative_args *) response.payload;

    
    return payload.returned;
}

int mcMoveRelativeUnits(motor_t motor, int distance, unit_type_t units) {
    
    struct _mcMoveRelativeUnits_args payload = {
        .distance = distance,
        .units = units
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcMoveRelativeUnits, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcMoveRelativeUnits_args *) response.payload;

    
    return payload.returned;
}

int mcPokeInteger(motor_t motor, motor_query_t query, int value) {
    
    struct _mcPokeInteger_args payload = {
        .query = query,
        .value = value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcPokeInteger, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcPokeInteger_args *) response.payload;

    
    return payload.returned;
}

int mcPokeString(motor_t motor, motor_query_t query, String * value) {
    if (value == NULL) return -EINVAL;
    struct _mcPokeString_args payload = {
        .query = query,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcPokeString, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcPokeString_args *) response.payload;

    
    return payload.returned;
}

int mcPokeStringItem(motor_t motor, motor_query_t query, String * value, String * item) {
    if (value == NULL) return -EINVAL;
    if (item == NULL) return -EINVAL;
    struct _mcPokeStringItem_args payload = {
        .query = query,
        .value = *value,
        .item = *item
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcPokeStringItem, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcPokeStringItem_args *) response.payload;

    
    return payload.returned;
}

int mcProfileGet(motor_t motor, OUT Profile * profile) {
    if (profile == NULL) return -EINVAL;
    struct _mcProfileGet_args payload = {
        .profile = *profile
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGet, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGet_args *) response.payload;

    memcpy(profile, &payload.profile, sizeof(Profile));
    return payload.returned;
}

int mcProfileGetAccel(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetAccel_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetAccel, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetAccel_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileGetDeadband(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetDeadband_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetDeadband, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetDeadband_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileGetDecel(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetDecel_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetDecel, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetDecel_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileGetInitialV(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetInitialV_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetInitialV, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetInitialV_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileGetMaxSlip(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetMaxSlip_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetMaxSlip, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetMaxSlip_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileGetMaxV(motor_t motor, Profile * profile, unit_type_t units,
    OUT int * value) {
    if (profile == NULL) return -EINVAL;
    if (value == NULL) return -EINVAL;
    struct _mcProfileGetMaxV_args payload = {
        .profile = *profile,
        .units = units,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileGetMaxV, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileGetMaxV_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcProfileSet(motor_t motor, Profile * profile) {
    if (profile == NULL) return -EINVAL;
    struct _mcProfileSet_args payload = {
        .profile = *profile
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcProfileSet, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcProfileSet_args *) response.payload;

    
    return payload.returned;
}

int mcQueryInteger(motor_t motor, motor_query_t query, OUT int * value) {
    if (value == NULL) return -EINVAL;
    struct _mcQueryInteger_args payload = {
        .query = query,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcQueryInteger, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcQueryInteger_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcQueryIntegerUnits(motor_t motor, motor_query_t query, OUT int * value, unit_type_t units) {
    if (value == NULL) return -EINVAL;
    struct _mcQueryIntegerUnits_args payload = {
        .query = query,
        .value = *value,
        .units = units
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcQueryIntegerUnits, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcQueryIntegerUnits_args *) response.payload;

    memcpy(value, &payload.value, sizeof(int));
    return payload.returned;
}

int mcQueryString(motor_t motor, motor_query_t query, OUT String * value) {
    if (value == NULL) return -EINVAL;
    struct _mcQueryString_args payload = {
        .query = query,
        .value = *value
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcQueryString, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcQueryString_args *) response.payload;

    memcpy(value, &payload.value, sizeof(String));
    return payload.returned;
}

int mcSearch(motor_t motor, String * driver, OUT String * results) {
    if (driver == NULL) return -EINVAL;
    if (results == NULL) return -EINVAL;
    struct _mcSearch_args payload = {
        .driver = *driver,
        .results = *results
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcSearch, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcSearch_args *) response.payload;

    memcpy(results, &payload.results, sizeof(String));
    return payload.returned;
}

int mcStop(motor_t motor) {
    
    struct _mcStop_args payload = {
        
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcStop, &payload,
        sizeof payload, PRIORITY_HIGH, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcStop_args *) response.payload;

    
    return payload.returned;
}

int mcTraceSubscribeAdd(motor_t motor, int id, String * name) {
    if (name == NULL) return -EINVAL;
    struct _mcTraceSubscribeAdd_args payload = {
        .id = id,
        .name = *name
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcTraceSubscribeAdd, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcTraceSubscribeAdd_args *) response.payload;

    
    return payload.returned;
}

int mcTraceSubscribeRemote(motor_t motor, int level, long long mask) {
    
    struct _mcTraceSubscribeRemote_args payload = {
        .level = level,
        .mask = mask
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcTraceSubscribeRemote, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcTraceSubscribeRemote_args *) response.payload;

    
    return payload.returned;
}

int mcTraceSubscribeRemove(motor_t motor, int id, String * name) {
    if (name == NULL) return -EINVAL;
    struct _mcTraceSubscribeRemove_args payload = {
        .id = id,
        .name = *name
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcTraceSubscribeRemove, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcTraceSubscribeRemove_args *) response.payload;

    
    return payload.returned;
}

int mcTraceUnsubscribeRemote(motor_t motor, int id) {
    
    struct _mcTraceUnsubscribeRemote_args payload = {
        .id = id
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcTraceUnsubscribeRemote, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcTraceUnsubscribeRemote_args *) response.payload;

    
    return payload.returned;
}

int mcUnitScaleGet(motor_t motor, OUT unit_type_t * units, OUT long long * urevs) {
    if (units == NULL) return -EINVAL;
    if (urevs == NULL) return -EINVAL;
    struct _mcUnitScaleGet_args payload = {
        .units = *units,
        .urevs = *urevs
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcUnitScaleGet, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcUnitScaleGet_args *) response.payload;

    memcpy(units, &payload.units, sizeof(unit_type_t));
    memcpy(urevs, &payload.urevs, sizeof(long long));
    return payload.returned;
}

int mcUnitScaleSet(motor_t motor, unit_type_t units, long long urevs) {
    
    struct _mcUnitScaleSet_args payload = {
        .units = units,
        .urevs = urevs
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcUnitScaleSet, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcUnitScaleSet_args *) response.payload;

    
    return payload.returned;
}

int mcUnitToMicroRevs(motor_t motor, unit_type_t unit, OUT long long * urevs) {
    if (urevs == NULL) return -EINVAL;
    struct _mcUnitToMicroRevs_args payload = {
        .unit = unit,
        .urevs = *urevs
    };
    response_message_t response;
    int size = mcMessageSendWait(motor, TYPE_mcUnitToMicroRevs, &payload,
        sizeof payload, PRIORITY_CMD, &response, &timeout);

    switch (size) {
        case -ENOENT:
        case -EAGAIN:
            return -ER_NO_DAEMON;
        case -ETIMEDOUT:
            return -ER_DAEMON_BUSY;
    }

    payload = * (struct _mcUnitToMicroRevs_args *) response.payload;

    memcpy(urevs, &payload.urevs, sizeof(long long));
    return payload.returned;
}
