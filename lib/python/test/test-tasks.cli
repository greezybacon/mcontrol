create cotask
    task consumer fork consumer
    task producer fork producer
    task consumer join

    succeed

    label producer
        let i = 1
        while True; do
            task consumer send i
            let i = i + 1
        done

    label consumer
        for x in range(20); do
            let j = [yield]
            print "Got {j}"
        done
        succeed

save

# Demonstrates an infinite producer and infinite consumer. The outer test
# controls both of them
create cotask2

    task consumer fork consumer
    task producer fork producer

    for x in range(30)
        task consumer send [task producer send]

    succeed

    label producer
        let i = 1
        while True; do
            yield i
            let i = i + i
        done

    label consumer
        while True; do
            print "Got [yield]"
            wait 0.01
        done
save

create parallel-tasks

    label main
        task task1 fork task1
        task task2 fork task2

        task task1 join
        task task2 join

        succeed

    label task1
        for x in range(10); do
            wait 0.08
            print "Task1: {x}"
        done

        succeed

    label task2
        for x in range(20); do
            wait 0.03
            print "Task2: {x}"
        done

        succeed

save

# Demonstrates a subtask that receives an argument and does processing
# based on the argument, which is not present in the outer environment

create task-with-args
    
    label main

        for x in range(1, 5); do
            let i = x * 30
            task worker fork worker with target=i
            task worker join
        done
        if [defined target]; fail "Scope leaked"
        succeed

    label worker

        let i = 1
        for x in range(target); do
            let i = i * 1.1
        done;
        print "1.1 ** {target} = {i}"
        succeed
save

run cotask
run cotask2
run parallel-tasks
run task-with-args
